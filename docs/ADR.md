### <a name="_b7urdng99y53"></a>**Название задачи:**
Проектирование схем коллекций для шардирования данных
### <a name="_hjk0fkfyohdk"></a>**Автор:**
Кенжебаев Руслан
### <a name="_uanumrh8zrui"></a>**Дата:**
06.01.2026
### <a name="_3bfxc9a45514"></a>**Функциональные требования**
| **№** | **Действующие лица или системы** | **Use Case**                                      | **Описание**                                                                                                                                              |
|:-----:|:---------------------------------|:--------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------|
|  U1   | Система                          | Расширился ассортимент товаров                    | Клиент в онлайн-магазине может купить не только аксессуары для смартфонов, но также электронику, аудио- и бытовую технику и другие категории товаров      |

### <a name="_u8xz25hbrgql"></a>**Нефункциональные требования**

| **№** | **Требование**                                                                                                    |
|:-----:|:------------------------------------------------------------------------------------------------------------------|
|   1   | Проанализировать атрибуты коллекций и выбрать потенциальных кандидатов для шард-ключей                            |
|   2   | Выбрать стратегию шардирования для каждой коллекции, которая обеспечит эффективное распределение данных по шардам |

### <a name="_qmphm5d6rvi3"></a>**Решение**
* Для коллекции Order в качестве ключа шардирования выбран идентификатор клиента (hashed customerId) - оптимально для запроса истории заказов пользователя 
Плюсом будет равномерное распределение данных по шардам
* Для коллекции Products в качестве ключа шардирования выбрана категория товара (categoryId), поскольку основные поиск товаров будет по категориям
* Для коллекции Cart в качестве ключа шардирования выбран идентификатор пользователя (hashed ownerKey) - не будет меняться при смене гостя на пользователя.
Оптимально для получения активной корзины. Плюсом будет равномерное распределение данных по шардам

[ER диаграмма коллекций](https://github.com/reverdp/architecture-pro-black_friday/blob/schemas/ER-Mobile_World_ER_Diagram.png)

### <a name="_bjrr7veeh80c"></a>**Альтернативы**
Как альтернатива можно для коллекции Products в качестве ключа шардирования выбрать идентификатор продукта, поиск товаров будет работать медленнее, плюсом будет равномерное распределение данных по шардам


**Недостатки, ограничения, риски**
* Риски шардирования для коллекции Order
Поиск по order_id без customer_id не таргетируется, а также запросы, например, за период или по статусу будут проходить по всем шардам

* Риски шардирования для коллекции Cart
Слияние гостевой корзины в пользовательскую - кросс-шард, session и user скорее будут в разных шардах

* Операция "создать заказ + списать остатки" возможно станет распределённой: заказ по на одном шарде, товар/остатки по на другом.
Риск: кросс-шард транзакция/согласованность. 
Возможное решение:вынести остатки в отдельную коллекцию.

---

### <a name="_b7urdng99y53"></a>**Название задачи:**
Выявление и устранение «горячих» шардов
### <a name="_hjk0fkfyohdk"></a>**Автор:**
Кенжебаев Руслан
### <a name="_uanumrh8zrui"></a>**Дата:**
07.01.2026
### <a name="_3bfxc9a45514"></a>**Функциональные требования**
| **№** | **Действующие лица или системы** | **Use Case**                                      | **Описание**                                                                                                                                              |
|:-----:|:---------------------------------|:--------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------|
|  U1   | Система                          | Неравномерное распределение товаров по категориям | 70% запросов приходится на товары из категории «Электроника»                                                                                              |

### <a name="_u8xz25hbrgql"></a>**Нефункциональные требования**

| **№** | **Требование**                                                                                  |
|:-----:|:------------------------------------------------------------------------------------------------|
|   1   | Разработать набор метрик, чтобы отслеживать состояние шардов                                    |
|   2   | Предложить механизмы автоматического перераспределения данных                                   |

### <a name="_qmphm5d6rvi3"></a>**Решение**
Набор метрик:
* Кол-во операций чтения/записи в сек
* CPU, RAM
* Connections
* Среднее число шардов на запрос (сколько шардов дергает один запрос)

Также реализовать алерт на превышение показателей по метрикам
Когда алерт срабатывает на основе метрик, определяем hot shard, коллекцию - выполнять миграции данных (moveChunk/moveRange)
Если срабатывает часто - рассмотреть вариант с пересмотром shard key

Рекомендуемый вариант исправления неравномерного распределения - составной shard key: { categoryId: 1, id: "hashed" }).
Ключ все еще содержит категорию, но также распределение будет и по id, что снижает вероятность, что вся Электроника будет на одном шарде

Также нужно использовать MongoDB Balancer, который следит за неравномерным распределением и мигрирует данные - проверить что бы он был включен

### <a name="_bjrr7veeh80c"></a>**Альтернативы**

**Недостатки, ограничения, риски**
* Возможно снижение производительности из-за частных миграций данных

---

### <a name="_b7urdng99y53"></a>**Название задачи:**
Настройка чтения с реплик и консистентность
### <a name="_hjk0fkfyohdk"></a>**Автор:**
Кенжебаев Руслан
### <a name="_uanumrh8zrui"></a>**Дата:**
06.01.2026
### <a name="_3bfxc9a45514"></a>**Функциональные требования**
| **№** | **Действующие лица или системы** | **Use Case**                  | **Описание**                                                                                                                                              |
|:-----:|:---------------------------------|:------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------|
|  U1   | Система                          | Увеличение производительности | Разделение запросов по репликам для увеличения скорости ответов                                                                                           |

### <a name="_u8xz25hbrgql"></a>**Нефункциональные требования**

| **№** | **Требование**                                                                       |
|:-----:|:-------------------------------------------------------------------------------------|
|   1   | Определить операции чтения, которые могут использовать secondary реплику для чтения. |
|   2   | Определить операции чтения, которые должны читать только с primary                   |
|   3   | Определить задержку репликации допустима для операций на secondary                   |

### <a name="_qmphm5d6rvi3"></a>**Решение**
Операции, которые могут использовать secondary реплику для чтения:
* История заказов - не крично небольшое отставание
* Поиск товаров, описание товара - данные меняются редко

Операции, которые должны читать только с primary:
* Отображение статуса заказа (сразу после оформления заказа, оплаты, отмены). Критично, т.к есть вероятность показать старый статус, пользователь будет пытаться повторять операцию
* Запрос остатков товаров при оформлении/списании (обновляются часто, риск продать товар, которого уже нет)
* Чтение корзины (корзина меняется очень часто, чтение с secondary вызовет ощущения, то товар не добавился/удалился, а также критично при оформлении заказа и слияния гостевой корзины с пользовательской)

Допустима задержка репликации 1-5 секунд для операций на secondary

### <a name="_bjrr7veeh80c"></a>**Альтернативы**

**Недостатки, ограничения, риски**
* Secondary отстаёт от primary. Пользователь может увидеть состояние устаревшие данные
* При сбоях и выборах нового primary часть записей может быть не видна на конкретной secondary в моменте

---

### <a name="_b7urdng99y53"></a>**Название задачи:**
Миграция на Cassandra: модель данных, стратегии репликации и шардирования
### <a name="_hjk0fkfyohdk"></a>**Автор:**
Кенжебаев Руслан
### <a name="_uanumrh8zrui"></a>**Дата:**
08.01.2026
### <a name="_3bfxc9a45514"></a>**Функциональные требования**
| **№** | **Действующие лица или системы** | **Use Case**                                  | **Описание**                                                                                                                                              |
|:-----:|:---------------------------------|:----------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------|
|  U1   | Система                          | Повышенная нагрузка во время проводимых акций | Резкое увеличении нагрузки во время «чёрной пятницы», что вызывало просадку latency в пик нагрузки, так как система тратила ресурсы на перемещение данных |

### <a name="_u8xz25hbrgql"></a>**Нефункциональные требования**

| **№** | **Требование**                                                                                                    |
|:-----:|:------------------------------------------------------------------------------------------------------------------|
|   1   | Миграция на Cassandra: разработать модель данных, стратегии репликации и шардирования                             |

### <a name="_qmphm5d6rvi3"></a>**Решение**

Критично по целостности
* Списание/резерв остатков
* Создание заказа, подтверждение оплаты, смена статуса заказа
* Корзина в момент оформления

Подходит для миграции на Cassandra:
* История заказов (много записей, чтение по пользователю)
* Информация по заказу (точечный запрос по id)
* Корзина
* Товары (справочные данные)

[Примеры таблиц в Cassandra](https://github.com/reverdp/architecture-pro-black_friday/blob/schemas/cassandra_examples.txt)

Стратегию Hinted Handoff можно применить для следующих сущностей:
* Cart
* product
* orders

Стратегию Read Repair можно применить для следующих сущностей:
* orders_by_id (статус заказа читают часто, важна актуальность)
* products - опционально (возможно хватит repair)

Стратегию Anti-Entropy Repair можно применить для следующих сущностей:
* orders - обязательно, итоговые статусы по заказам критичны
* products - желательно, продукты в итоге тоже должны быть согласованы
* carts - можно реже, т.к жизненный цикл короткий

### <a name="_bjrr7veeh80c"></a>**Альтернативы**

**Недостатки, ограничения, риски**
* Возможно на первом этапе нужно будет писать сразу в две базы mongo и cassandra, из-за этого может быть рассинхронизация данных
* Быстрый рост данных, например, истории заказов, из-за этого деградация по чтению, возможно нужно еще разбивать по времени